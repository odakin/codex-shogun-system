#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import sqlite3
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path


def utc_now() -> str:
    return datetime.now(timezone.utc).replace(microsecond=0).isoformat()


def root_dir() -> Path:
    return Path(__file__).resolve().parent.parent


def db_path() -> Path:
    return root_dir() / "state" / "shogun.db"


def state_dir() -> Path:
    return root_dir() / "state"


def team_meta_file() -> Path:
    return state_dir() / "team-meta.json"


def ensure_db() -> None:
    ctl = root_dir() / "bin" / "shogunctl"
    subprocess.run([str(ctl), "init"], check=True, stdout=subprocess.DEVNULL)


def connect() -> sqlite3.Connection:
    conn = sqlite3.connect(str(db_path()))
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    return conn


def parse_kv_args(items: list[str]) -> dict[str, str]:
    payload: dict[str, str] = {}
    for item in items:
        if "=" not in item:
            raise ValueError(f"expected key=value argument, got: {item}")
        key, value = item.split("=", 1)
        payload[key.strip()] = value
    return payload


def to_bool(value: str | None, default: bool = False) -> bool:
    if value is None:
        return default
    return value.lower() in {"1", "true", "yes", "on"}


def cmd_team_create(payload: dict[str, str]) -> int:
    team_name = payload.get("team_name", "shogun-team")
    ensure_db()
    state_dir().mkdir(parents=True, exist_ok=True)
    data = {
        "team_name": team_name,
        "created_at": utc_now(),
        "updated_at": utc_now(),
    }
    team_meta_file().write_text(json.dumps(data, ensure_ascii=True, indent=2), encoding="utf-8")
    print(json.dumps({"ok": True, "team_name": team_name}, ensure_ascii=True))
    return 0


def cmd_send_message(payload: dict[str, str]) -> int:
    mode = payload.get("mode", "teams")
    sender = payload.get("sender", payload.get("from", "system"))
    msg_type = payload.get("type", "message")
    recipient = payload.get("recipient")
    content = payload.get("content", "")
    summary = payload.get("summary")
    task_id = payload.get("taskId") or payload.get("task_id")

    cmd = [str(root_dir() / "bin" / "shogun-comm"), "--mode", mode, "send", "--from", sender, "--content", content]
    if msg_type == "broadcast":
        cmd.append("--broadcast")
    else:
        if not recipient:
            print("error: recipient is required for type=message", file=sys.stderr)
            return 1
        cmd.extend(["--to", recipient])
    if summary:
        cmd.extend(["--summary", summary])
    if task_id:
        cmd.extend(["--task-id", task_id])
    subprocess.run(cmd, check=True)
    return 0


def cmd_task_create(payload: dict[str, str]) -> int:
    ensure_db()
    cmd = [
        str(root_dir() / "bin" / "shogunctl"),
        "task",
        "create",
        "--actor",
        payload.get("actor", payload.get("reporter", "system")),
        "--subject",
        payload.get("subject", ""),
        "--description",
        payload.get("description", ""),
    ]
    if payload.get("owner"):
        cmd.extend(["--owner", payload["owner"]])
    if payload.get("reporter"):
        cmd.extend(["--reporter", payload["reporter"]])
    if payload.get("reviewer"):
        cmd.extend(["--reviewer", payload["reviewer"]])
    if payload.get("priority"):
        cmd.extend(["--priority", payload["priority"]])
    if payload.get("parent_id"):
        cmd.extend(["--parent-id", payload["parent_id"]])
    result = subprocess.run(cmd, check=True, capture_output=True, text=True)
    print(result.stdout.strip())
    return 0


def cmd_task_update(payload: dict[str, str]) -> int:
    ensure_db()
    task_id = payload.get("taskId") or payload.get("task_id")
    if not task_id:
        print("error: taskId is required", file=sys.stderr)
        return 1
    cmd = [
        str(root_dir() / "bin" / "shogunctl"),
        "task",
        "update",
        "--id",
        task_id,
        "--actor",
        payload.get("actor", "system"),
    ]
    for src, arg in (
        ("status", "--status"),
        ("owner", "--owner"),
        ("reviewer", "--reviewer"),
        ("priority", "--priority"),
        ("subject", "--subject"),
        ("description", "--description"),
    ):
        if payload.get(src):
            cmd.extend([arg, payload[src]])
    subprocess.run(cmd, check=True)
    return 0


def cmd_task_list(payload: dict[str, str]) -> int:
    ensure_db()
    cmd = [str(root_dir() / "bin" / "shogunctl"), "task", "list", "--json"]
    if payload.get("owner"):
        cmd.extend(["--owner", payload["owner"]])
    if payload.get("status"):
        cmd.extend(["--status", payload["status"]])
    if payload.get("limit"):
        cmd.extend(["--limit", payload["limit"]])
    subprocess.run(cmd, check=True)
    return 0


def cmd_task_spawn(payload: dict[str, str]) -> int:
    # Compatibility shim for Task(subagent_type=..., name=..., mode=..., prompt=...)
    # We register the member so the orchestration layer can target it.
    ensure_db()
    name = payload.get("name")
    if not name:
        print("error: name is required", file=sys.stderr)
        return 1
    role = payload.get("mode", payload.get("role", "worker"))
    now = utc_now()
    with connect() as conn:
        conn.execute(
            """
            INSERT INTO members(name, role, status, session, pane, created_at, updated_at)
            VALUES (?, ?, 'idle', NULL, NULL, ?, ?)
            ON CONFLICT(name) DO UPDATE SET
              role = excluded.role,
              updated_at = excluded.updated_at
            """,
            (name, role, now, now),
        )
    response = {
        "ok": True,
        "name": name,
        "role": role,
        "subagent_type": payload.get("subagent_type", "general-purpose"),
        "team_name": payload.get("team_name"),
        "prompt": payload.get("prompt"),
    }
    print(json.dumps(response, ensure_ascii=True))
    return 0


def cmd_call(args: argparse.Namespace) -> int:
    try:
        payload = parse_kv_args(args.kv)
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    api = args.api_name
    if api == "TeamCreate":
        return cmd_team_create(payload)
    if api == "SendMessage":
        return cmd_send_message(payload)
    if api == "TaskCreate":
        return cmd_task_create(payload)
    if api == "TaskUpdate":
        return cmd_task_update(payload)
    if api == "TaskList":
        return cmd_task_list(payload)
    if api == "Task":
        return cmd_task_spawn(payload)

    print(f"error: unsupported API '{api}'", file=sys.stderr)
    return 1


def cmd_demo(_: argparse.Namespace) -> int:
    examples = [
        ["TeamCreate", "team_name=shogun-team"],
        [
            "Task",
            "subagent_type=general-purpose",
            "team_name=shogun-team",
            "name=karo",
            "mode=delegate",
            "prompt=Read instructions/karo.md",
        ],
        ["TaskCreate", "actor=shogun", "owner=karo", "subject=WBS update", "description=decompose work"],
        ["TaskUpdate", "taskId=1", "actor=shogun", "owner=karo"],
        ["SendMessage", "type=message", "sender=shogun", "recipient=karo", "content=Task assigned"],
        ["TaskList", "owner=karo"],
    ]
    for ex in examples:
        print(" ".join([str(root_dir() / "bin" / "shogun-api"), *ex]))
    return 0


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Compatibility API wrapper for Shogun system")
    sub = parser.add_subparsers(dest="command", required=True)

    p_call = sub.add_parser("call", help="Call API by name with key=value args")
    p_call.add_argument("api_name", choices=("TeamCreate", "SendMessage", "TaskCreate", "TaskUpdate", "TaskList", "Task"))
    p_call.add_argument("kv", nargs="*", help="key=value parameters")
    p_call.set_defaults(func=cmd_call)

    p_demo = sub.add_parser("demo", help="Print API usage examples")
    p_demo.set_defaults(func=cmd_demo)
    return parser


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    return int(args.func(args))


if __name__ == "__main__":
    sys.exit(main())

